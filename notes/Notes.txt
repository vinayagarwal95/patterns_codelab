In this codelab we are diving into the dart's pattern and records feature:

1. Create and return a record:

In "data.dart" we have created a getter method to the Document class called 'metadata' that returns a record.

getter method metadata:

lib/data.dart:

(String, {DateTime modified}) get metadata {
    const title = 'My Document';
    final now = DateTime.now();

    return (title, modified: now);
  }  


The return type for this function is a record with two fields, one with the type String, and the other with the type DateTime.

The first field is positional and unnamed, and the second field is named modified.


2. Access Record fields:

In the DocumentScreen widget we call the 'metadata' getter function in the build method so that we can get the record and access its values.


lib/main.dart:

class DocumentScreen extends StatelessWidget {
  final Document document;

  const DocumentScreen({
    required this.document,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    final metaDataRecord = document.metadata;              // Add this line.

    return Scaffold(
      appBar: AppBar(
        title: Text(metaDataRecord.$1),                    // Modify this line,
      ),
      body: Column(
        children: [
          Center(
            child: Text(
              'Last modified ${metaDataRecord.modified}',  // And this one.
            ),
          ),
        ],
      ),
    );
  }
}


The metadata getter method returns a record, which is assigned to the local variable metaDataRecord. Records are a light and easy way to return multiple values from a single function call and assign them to a variable.

To access the individual fields composed in that record, you can use records' built-in getter syntax.

To get a positional field (a field without a name, like title), use the getter $<num> on the record. This returns only unnamed fields.
Named fields like modified don't have a positional getter, so you can use its name directly, like metadataRecord.modified.
To determine the name of a getter for a positional field, start at $1 and skip named fields. For example:


var record = (named: 'v', 'y', named2: 'x', 'z');
print(record.$1);                               // prints y
print(record.$2);                               // prints z


3. Match and destructure using patterns:


Records can efficiently collect different types of data and easily pass it around. Now, improve your code using patterns.

A pattern represents a structure that one or more values can take, like a blueprint. Patterns compare against actual values to determine if they match.

Some patterns, when they match, destructure the matched value by pulling data out of it. Destructuring lets you unpack values from an object to assign them to local variables, or perform further matching on them.

Destructure a record into local variables
Refactor the build method of DocumentScreen to call metadata and use it to initialize a pattern variable declaration:
lib/main.dart

class DocumentScreen extends StatelessWidget {
  final Document document;

  const DocumentScreen({
    required this.document,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    final (title, modified: modified) = document.metadata;   // Modify

    return Scaffold(
      appBar: AppBar(
        title: Text(title),                                  // Modify
      ),
      body: Column(
        children: [
          Center(
            child: Text(
              'Last modified $modified',                     // Modify
            ),
          ),
        ],
      ),
    );
  }
}
The record pattern (title, modified: modified) contains two variable patterns that match against the fields of the record returned by metadata.

The expression matches the subpattern because the result is a record with two fields, one of which is named modified.
Because they match, the variable declaration pattern destructures the expression, accessing its values and binding them to new local variables of the same types and names, String title and DateTime modified.
There is a shorthand for when the name of a field and the variable populating it are the same. Refactor the build method of DocumentScreen as follows.

lib/main.dart

class DocumentScreen extends StatelessWidget {
  final Document document;

  const DocumentScreen({
    required this.document,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    final (title, :modified) = document.metadata;            // Modify

    return Scaffold(
      appBar: AppBar(
        title: Text(title),
      ),
      body: Column(
        children: [
          Center(
            child: Text(
              'Last modified $modified',
            ),
          ),
        ],
      ),
    );
  }
}
The syntax of the variable pattern :modified is shorthand for modified: modified. If you want a new local variable of a different name, you can write modified: localModified instead.

4. Use patterns to extract data

In certain contexts, patterns don't only match and destructure but can also make a decision about what the code does, based on whether or not the pattern matches. These are called refutable patterns.

The variable declaration pattern you used in the last step is an irrefutable pattern: the value must match the pattern or it's an error and destructuring won't happen. Think of any variable declaration or assignment; you can't assign a value to a variable if they're not the same type.

Refutable patterns, on the other hand, are used in control flow contexts:

They expect that some values they compare against will not match.
They are meant to influence the control flow, based on whether or not the value matches.
They don't interrupt execution with an error if they don't match, they just move to the next statement.
They can destructure and bind variables that are only usable when they match
Read JSON values without patterns
In this section, you read data without pattern matching to see how patterns can help you work with JSON data.

Replace the previous version of metadata with one that reads values from the _json map. Copy and paste this version of metadata into the Document class:
lib/data.dart

class Document {
  final Map<String, Object?> _json;
  Document() : _json = jsonDecode(documentJson);

  (String, {DateTime modified}) get metadata {
    if (_json.containsKey('metadata')) {                     // Modify from here...
      final metadataJson = _json['metadata'];
      if (metadataJson is Map) {
        final title = metadataJson['title'] as String;
        final localModified =
            DateTime.parse(metadataJson['modified'] as String);
        return (title, modified: localModified);
      }
    }
    throw const FormatException('Unexpected JSON');          // to here.
  }
}
This code validates that the data is structured correctly without using patterns. In a later step, you use pattern matching to perform the same validation using less code. It performs three checks before doing anything else:

The JSON contains the data structure you expect: if (_json.containsKey('metadata'))
The data has the type you expect: if (metadataJson is Map)
That the data is not null, which is implicitly confirmed in the previous check.
Read JSON values using a map pattern
With a refutable pattern, you can verify that the JSON has the expected structure using a map pattern.

Replace the previous version of metadata with this code:
lib/data.dart

class Document {
  final Map<String, Object?> _json;
  Document() : _json = jsonDecode(documentJson);

  (String, {DateTime modified}) get metadata {
    if (_json                                                // Modify from here...
        case {
          'metadata': {
            'title': String title,
            'modified': String localModified,
          }
        }) {
      return (title, modified: DateTime.parse(localModified));
    } else {
      throw const FormatException('Unexpected JSON');
    }                                                        // to here.
  }
}
Here, you see a new kind of if-statement (introduced in Dart 3), the if-case. The case body only executes if the case pattern matches the data in _json. This match accomplishes the same checks you wrote in the first version of metadata to validate the incoming JSON. This code validates the following:

_json is a Map type.
_json contains a metadata key.
_json is not null.
_json['metadata'] is also a Map type.
_json['metadata'] contains the keys title and modified.
title and localModified are strings and aren't null.
If the value doesn't match, the pattern refutes (refuses to continue execution) and proceeds to the else clause. If the match is successful, the pattern destructures the values of title and modified from the map and binds them to new local variables.

